---
layout: default
title: So what's Mlatu?
parent: Introduction
nav_order: 1
permalink: /so-whats-mlatu
---

## So what's Mlatu?

Mlatu is a **purely functional programming language**. In imperative languages you get things done by giving the computer a sequence of tasks and then it executes them. While executing them, it can change state. For instance, you set variable `a` to 5 and then do some stuff and then set it to something else. You have control flow structures for doing some action several times. In purely functional programming you don't tell the computer what to do as such but rather you tell it what stuff is. The factorial of a number is the product of all the numbers from 1 to that number, the sum of a list of numbers is the first number plus the sum of all the other numbers, and so on. You express that in the forms of functions. You also can't set a variable to something and then set it to something else later. If you say that `a` is 5, you can't say it's something else later because you just said it was `5`. What are you, some kind of liar? So in purely functional languages, a function has no side effects. The only thing a function can do is calculate something and return it as a result. At first, this seems kind of limiting but it actually has some very nice consequences: if a function is called twice with the same parameters, it's guaranteed to return the same result. That's called referential transparency and not only does it allow the compiler to reason about the program's behavior, but it also allows you to easily deduce (and even prove) that a function is correct and then build more complex functions by gluing simple functions together.

Mlatu is **concatenative**. Almost all imperative languages and functional languages are applicative. Applicative languages get stuff done by *applying* functions to their arguments, while concatenative languages get stuff done by *composing* functions. While I'll talk of applying functions in this tutorial, it's a bit of a facade because everything in Mlatu is a function, and a program is also a function formed by composing the component terms of the program. Values like `2` or `3` are really just functions that return numbers when called. In concatenative programming, the data flows in the order the program is written in, which means little-to-no backtracking when reading a concatenative programming. The best explanation I've seen for why concatenative programming matters is the aptly-named [Why Concatenative Programming Matters](https://evincarofautumn.blogspot.com/2012/02/why-concatenative-programming-matters.html).

Mlatu is **statically typed**. When you compile your program, the compiler knows which piece of code is a number, which is a string, and so on. That means a lot of possible errors are caught at compile time. If you try to add together a number and a string, the compiler will complain at you. Mlatu uses a very good type system that has `type inference`. That means that you don't have to explicitly label every piece of code with a type because the type system can intelligently figure out a lot about it. If you say `5 4 + -> a;`, you don't have to tell Mlatu that `a` is a number, it can figure that out by itself. Type inference also allows your code to be more general. If a function you make takes two parameters and adds them together and you don't explicitly state their type, the function will work on any two parameters that act like numbers.

Mlatu is **elegant and concise**. Because it uses a lot of high level concepts, Mlatu prograams are usually shorter than imperative equivalents. And shorter programs are easier to maintain than longer ones and have less bugs.